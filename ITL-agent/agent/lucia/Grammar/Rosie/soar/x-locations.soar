#   Soar code produced automatically 
#   from file '..\Lucia\Grammars\Rosie\ecg\x-locations.ecg'.

#   MapLocation schema
sp {comprehend-word*evoked-schema*MapLocation*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema MapLocation
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>)
   (<e-target> ^schema-name MapLocation
               ^is <a>
               ^constraint <c1>)
   (<a> ^a MapLocation)
   (<e1> ^schema KnownObject
         ^target <e-target>)
   (<e2> ^schema RosieObject
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value location)
}

#   MapLocation schema
sp {comprehend-word*evoked-schema*MapLocation*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema MapLocation
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>)
   (<a> ^a MapLocation)
   (<e1> ^schema KnownObject
         ^target <e-target>)
   (<e2> ^schema RosieObject
         ^target <e-target>)
   (<e-target> ^constraint <c1>)
   (<c1> ^attr rosie-category
         ^value location)
}

#   Kitchen schema
sp {comprehend-word*evoked-schema*Kitchen*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Kitchen
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Kitchen
               ^is <a>
               ^constraint <c1>)
   (<a> ^a Kitchen)
   (<e1> ^schema MapLocation
         ^target <e-target>)
   (<c1> ^attr handle
         ^value loc-kitchen1)
}

#   Kitchen schema
sp {comprehend-word*evoked-schema*Kitchen*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Kitchen
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a Kitchen)
   (<e1> ^schema MapLocation
         ^target <e-target>)
   (<e-target> ^constraint <c1>)
   (<c1> ^attr handle
         ^value loc-kitchen1)
}

#   ConferenceRoom schema
sp {comprehend-word*evoked-schema*ConferenceRoom*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema ConferenceRoom
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name ConferenceRoom
               ^is <a>
               ^constraint <c1>)
   (<a> ^a ConferenceRoom)
   (<e1> ^schema MapLocation
         ^target <e-target>)
   (<c1> ^attr handle
         ^value loc-conf1)
}

#   ConferenceRoom schema
sp {comprehend-word*evoked-schema*ConferenceRoom*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema ConferenceRoom
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a ConferenceRoom)
   (<e1> ^schema MapLocation
         ^target <e-target>)
   (<e-target> ^constraint <c1>)
   (<c1> ^attr handle
         ^value loc-conf1)
}

#   Building schema
sp {comprehend-word*evoked-schema*Building*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Building
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Building
               ^is <a>
               ^constraint <c1>)
   (<a> ^a Building)
   (<e1> ^schema MapLocation
         ^target <e-target>)
   (<c1> ^attr handle
         ^value building1)
}

#   Building schema
sp {comprehend-word*evoked-schema*Building*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Building
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a Building)
   (<e1> ^schema MapLocation
         ^target <e-target>)
   (<e-target> ^constraint <c1>)
   (<c1> ^attr handle
         ^value building1)
}

#   Office schema
sp {comprehend-word*evoked-schema*Office*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Office
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Office
               ^is <a>
               ^constraint <c1>)
   (<a> ^a Office)
   (<e1> ^schema MapLocation
         ^target <e-target>)
   (<c1> ^attr handle
         ^value office1)
}

#   Office schema
sp {comprehend-word*evoked-schema*Office*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Office
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a Office)
   (<e1> ^schema MapLocation
         ^target <e-target>)
   (<e-target> ^constraint <c1>)
   (<c1> ^attr handle
         ^value office1)
}

#   MainOffice schema
sp {comprehend-word*evoked-schema*MainOffice*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema MainOffice
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name MainOffice
               ^is <a>
               ^constraint <c1>)
   (<a> ^a MainOffice)
   (<e1> ^schema MapLocation
         ^target <e-target>)
   (<c1> ^attr handle
         ^value loc-main1)
}

#   MainOffice schema
sp {comprehend-word*evoked-schema*MainOffice*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema MainOffice
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a MainOffice)
   (<e1> ^schema MapLocation
         ^target <e-target>)
   (<e-target> ^constraint <c1>)
   (<c1> ^attr handle
         ^value loc-main1)
}

#   SoarOffice schema
sp {comprehend-word*evoked-schema*SoarOffice*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema SoarOffice
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name SoarOffice
               ^is <a>
               ^constraint <c1>)
   (<a> ^a SoarOffice)
   (<e1> ^schema MapLocation
         ^target <e-target>)
   (<c1> ^attr handle
         ^value loc-soar1)
}

#   SoarOffice schema
sp {comprehend-word*evoked-schema*SoarOffice*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema SoarOffice
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a SoarOffice)
   (<e1> ^schema MapLocation
         ^target <e-target>)
   (<e-target> ^constraint <c1>)
   (<c1> ^attr handle
         ^value loc-soar1)
}

